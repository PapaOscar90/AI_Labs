1.
FIFO (BFS)
0->99  == 28091 nodes visited. 126169 nodes still in the queue.

0->100 == insertFringe(..): fatal error, out of memory.

0->102 == 29325 nodes visited. 132124 nodes still in the queue.


STACK (DFS)

1->0   == 2 nodes visited 5 nodes still in the queue.

0->1   == insertFringe(..): fatal error, out of memory.

In FIFO, a very large amount of nodes are visited, and an even larger
amount still in the queue, with one case running out of memory. For the
LIFO/STACK, We have ourselves a case of an infinite branch. In case 
0->1, 0 is popped, and all the cases up to 0/3 are pushed. 0/3 = 0,
and that is popped again, and the loop restarts. For 1->0, 1 is checked, 
then all cases up to 1/3 are pushed, and 1/3 = 0, which is popped,
and evaluates to the correct answer. 

In both the FIFO and the STACK, these issues may be resolved by keeping
track of visited nodes and only feeding the fringe if the node is 
unvisited.

2. By keeping track of visited nodes, the FIFO/BFS improves drastically. But
because of the properties of DFS with a LIFO, a lot of values still loop 
indefinitely.
  

FIFO (BFS)
0->99  == 87 nodes visited. 95 nodes still in the queue.

0->100 == 155 nodes visited. 169 nodes still in the queue.

0->102 == 105 nodes visited. 114 nodes still in the queue.


STACK (DFS)

1->0   == 2 nodes visited. 2 nodes still in the queue.

0->1   == 2 nodes visited. 0 nodes still in the queue.

3. Done.

4.



